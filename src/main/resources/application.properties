# ===================================================================
# SERVER CONFIGURATION
# ===================================================================
# Port that the User Service will run on. Let's use 8081.
server.port=8081

# ===================================================================
# DATABASE CONNECTION (DATASOURCE)
# ===================================================================
# The JDBC URL for PostgreSQL.
# Format: jdbc:postgresql://<host>:<port>/<database_name>
# 'localhost:5432' is the standard for a local install.
# 'user_service_db' is the database we just created.
spring.datasource.url=jdbc:postgresql://localhost:5432/user_service_db

# Your PostgreSQL username and password.
# The default username is often 'postgres'. Change if yours is different.
spring.datasource.username=myuser # Must match the user in docker-compose.yml
spring.datasource.password=mypassword # Must match the password in docker-compose.yml

# The specific driver class for PostgreSQL.
spring.datasource.driver-class-name=org.postgresql.Driver

# ===================================================================
# JPA / HIBERNATE CONFIGURATION
# ===================================================================
# 'update' means Hibernate will look at your @Entity classes and automatically
# create or update the database tables to match them.
# Other options: 'create' (drops and recreates tables every time), 'validate', 'none'.
spring.jpa.hibernate.ddl-auto=update

# This tells Hibernate which "flavor" of SQL to generate.
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# (Optional but highly recommended for development)
# This will print the actual SQL queries that Hibernate generates to the console.
# It's extremely useful for debugging.
spring.jpa.show-sql=true